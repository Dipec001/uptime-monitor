name: Application CI/CD

on:
  push:
    branches:
      - main
      - dev
    # Only trigger if app code changes, ignore Terraform and docs
    paths-ignore:
      - 'tf-infra/**'
      - '**/*.md'
      - 'docs/**'
      - 'frontend/**'  # Ignore frontend changes for backend CI/CD
      
env:
  PROJECT_NAME: "uptime-monitor"
  AWS_REGION: "us-east-1"
  ECR_REGISTRY_ALIAS: v9n7w5d9
  ECR_REPOSITORY: uptimemonitor

jobs:
  lint-test:
    name: Lint & Test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: mypassword
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    env:
      DATABASE_URL: postgres://postgres:mypassword@localhost:5432/test_db
      SECRET_KEY: test-secret
      DEBUG: "true"

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.12

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}  
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run Linter
        run: flake8 .

      - name: Run Tests
        run: pytest -v
      
      - name: Run Trivy vulnerability scanner (Filesystem)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run Trivy secret scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          scanners: 'secret'
          format: 'table'
          exit-code: '1'

  docker-build-push:
    name: Docker Build & Push
    needs: lint-test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      image: ${{ steps.build-image.outputs.image }}
      environment: ${{ steps.set-env.outputs.environment }}

    steps:
      - uses: actions/checkout@v4

      - name: Set Environment
        id: set-env
        run: |
          if [ "${GITHUB_REF_NAME}" == "main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR Public
        id: login-ecr-public
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build, Tag, and Push Docker Image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr-public.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          ENVIRONMENT: ${{ steps.set-env.outputs.environment }}
        run: |
          # Build full image path
          IMAGE_PATH=$ECR_REGISTRY/$ECR_REGISTRY_ALIAS/$ECR_REPOSITORY
          
          echo "Building Docker image for $ENVIRONMENT..."
          docker build -t $IMAGE_PATH:$IMAGE_TAG .
          
          # Tag with environment-specific latest
          docker tag $IMAGE_PATH:$IMAGE_TAG $IMAGE_PATH:$ENVIRONMENT-latest
          
          # Push both tags
          echo "Pushing image with SHA tag: $IMAGE_TAG"
          docker push $IMAGE_PATH:$IMAGE_TAG
          docker push $IMAGE_PATH:$ENVIRONMENT-latest
          
          # Output the full image path for next job
          echo "image=$IMAGE_PATH:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "‚úÖ Image pushed: $IMAGE_PATH:$IMAGE_TAG"
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build-image.outputs.image }}
          format: 'table'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'


  deploy-to-ecs:
    name: Deploy to ECS
    needs: docker-build-push
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.docker-build-push.outputs.environment }}

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Deploy to ECS
        env:
          ENVIRONMENT: ${{ needs.docker-build-push.outputs.environment }}
          NEW_IMAGE: ${{ needs.docker-build-push.outputs.image }}
        run: |
          echo "üöÄ Deploying to $ENVIRONMENT environment..."
          echo "üì¶ New image: $NEW_IMAGE"
          
          CLUSTER="${ENVIRONMENT}-uptimemonitor-cluster"
          SERVICE="${ENVIRONMENT}-uptimemonitor-service"
          TASK_FAMILY="${ENVIRONMENT}-uptimemonitor"
          
          # Get current task definition
          echo "üì• Fetching current task definition..."
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition $TASK_FAMILY \
            --query 'taskDefinition' \
            --region $AWS_REGION)
          
          # Update all container images (web, celery, beat)
          echo "üîÑ Updating container images..."
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq --arg IMAGE "$NEW_IMAGE" '
            .containerDefinitions |= map(
              .image = $IMAGE
            ) |
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, 
                .compatibilities, .registeredAt, .registeredBy)
          ')
          
          # Register new task definition revision
          echo "üìù Registering new task definition..."
          NEW_REVISION=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --region $AWS_REGION \
            --query 'taskDefinition.revision' \
            --output text)
          
          echo "‚úÖ New task definition revision: $TASK_FAMILY:$NEW_REVISION"
          
          # Update service with new task definition
          echo "üîÑ Updating ECS service..."
          aws ecs update-service \
            --cluster $CLUSTER \
            --service $SERVICE \
            --task-definition "$TASK_FAMILY:$NEW_REVISION" \
            --force-new-deployment \
            --region $AWS_REGION \
            --query 'service.taskDefinition' \
            --output text
          
          echo "‚è≥ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster $CLUSTER \
            --service $SERVICE \
            --region $AWS_REGION
          
          # Verify deployment
          RUNNING_TASKS=$(aws ecs list-tasks \
            --cluster $CLUSTER \
            --service-name $SERVICE \
            --desired-status RUNNING \
            --region $AWS_REGION \
            --query 'taskArns[0]' \
            --output text)
          
          if [ "$RUNNING_TASKS" != "None" ]; then
            TASK_IMAGE=$(aws ecs describe-tasks \
              --cluster $CLUSTER \
              --tasks $RUNNING_TASKS \
              --region $AWS_REGION \
              --query 'tasks[0].containers[0].image' \
              --output text)
            
            echo "üéØ Currently running image: $TASK_IMAGE"
            
            if [ "$TASK_IMAGE" == "$NEW_IMAGE" ]; then
              echo "‚úÖ Deployment successful! New image is running."
            else
              echo "‚ö†Ô∏è  Warning: Running image doesn't match expected image"
              exit 1
            fi
          fi
          
          echo "üéâ Deployment complete!"