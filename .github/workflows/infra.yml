name: Infrastructure CI/CD

on:
  push:
    branches:
      - main
      - dev
    paths:
      - 'tf-infra/**'
  workflow_dispatch:

jobs:
  terraform-deploy:
    name: Terraform Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      id-token: write

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.3
      
      - name: Run Trivy vulnerability scanner (IaC)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'config'
          scan-ref: 'tf-infra/'
          format: 'sarif'
          output: 'trivy-iac-results.sarif'
          exit-code: '0'

      - name: Upload Trivy IaC results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-iac-results.sarif'

      - name: Determine Environment & Variables
        id: env_select
        run: |
          if [ "${GITHUB_REF_NAME}" == "main" ]; then
            echo "env=prod" >> $GITHUB_OUTPUT
            echo "tf_dir=tf-infra/prod" >> $GITHUB_OUTPUT
            echo "tfvars_file=prod.tfvars" >> $GITHUB_OUTPUT
            echo "ecr_repo_url=${{ secrets.PROD_ECR_REPO_URL }}" >> $GITHUB_OUTPUT
            echo "is_prod=true" >> $GITHUB_OUTPUT
          else
            echo "env=staging" >> $GITHUB_OUTPUT
            echo "tf_dir=tf-infra/staging" >> $GITHUB_OUTPUT
            echo "tfvars_file=dev.tfvars" >> $GITHUB_OUTPUT
            echo "is_prod=false" >> $GITHUB_OUTPUT
            echo "ecr_repo_url=${{ secrets.STAGING_ECR_REPO_URL }}" >> $GITHUB_OUTPUT
          fi

      - name: Initialize Terraform
        run: |
          echo "Initializing Terraform in ${{ steps.env_select.outputs.tf_dir }}..."
          terraform -chdir=${{ steps.env_select.outputs.tf_dir }} init -input=false

      # Staging Plan (without Cloudflare)
      - name: Terraform Plan (Staging)
        if: steps.env_select.outputs.is_prod == 'false'
        run: |
          echo "Running Terraform plan for staging..."
          terraform -chdir=${{ steps.env_select.outputs.tf_dir }} plan \
            -var-file=${{ steps.env_select.outputs.tfvars_file }} \
            -var "db_username=${{ secrets.STAGING_DB_USERNAME }}" \
            -var "db_password=${{ secrets.STAGING_DB_PASSWORD }}" \
            -var "ecr_repo_url=${{ secrets.STAGING_ECR_REPO_URL }}" \
            -out=tfplan

      # Production Plan (with Cloudflare)
      - name: Terraform Plan (Production)
        if: steps.env_select.outputs.is_prod == 'true'
        run: |
          echo "Running Terraform plan for production..."
          terraform -chdir=${{ steps.env_select.outputs.tf_dir }} plan \
            -var-file=${{ steps.env_select.outputs.tfvars_file }} \
            -var "db_username=${{ secrets.PROD_DB_USERNAME }}" \
            -var "db_password=${{ secrets.PROD_DB_PASSWORD }}" \
            -var "ecr_repo_url=${{ secrets.PROD_ECR_REPO_URL }}" \
            -var "cloudflare_api_token=${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -var "cloudflare_zone_id=${{ secrets.CLOUDFLARE_ZONE_ID }}" \
            -var "grafana_admin_password=${{ secrets.GRAFANA_ADMIN_PASSWORD }}" \
            -out=tfplan

      - name: Terraform Apply
        run: |
          echo "Applying Terraform for ${{ steps.env_select.outputs.env }}..."
          terraform -chdir=${{ steps.env_select.outputs.tf_dir }} apply -auto-approve tfplan

      - name: Get Latest Application Image
        id: get_image
        env:
          ENVIRONMENT: ${{ steps.env_select.outputs.env }}
          ECR_REPO_URL: ${{ steps.env_select.outputs.ecr_repo_url }}
        run: |
          # Try to get the latest image with environment tag
          if [ -z "$ECR_REPO_URL" ]; then
            echo "Error: ECR_REPO_URL is empty!"
            exit 1
          fi
          LATEST_IMAGE="${ECR_REPO_URL}:${ENVIRONMENT}-latest"
          
          # Verify image exists
          if aws ecr-public describe-images \
            --repository-name uptimemonitor \
            --image-ids imageTag=${ENVIRONMENT}-latest \
            --region us-east-1 2>/dev/null; then
            echo "image=$LATEST_IMAGE" >> $GITHUB_OUTPUT
            echo "Found image: $LATEST_IMAGE"
          else
            echo "Warning: No ${ENVIRONMENT}-latest image found. Skipping ECS update."
            echo "image=" >> $GITHUB_OUTPUT
          fi

      - name: Update ECS Service with Latest Image
        if: steps.get_image.outputs.image != ''
        env:
          ENVIRONMENT: ${{ steps.env_select.outputs.env }}
          NEW_IMAGE: ${{ steps.get_image.outputs.image }}
        run: |
          echo "Updating ECS service with image: $NEW_IMAGE"
          
          CLUSTER="${ENVIRONMENT}-uptimemonitor-cluster"
          SERVICE="${ENVIRONMENT}-uptimemonitor-service"
          TASK_FAMILY="${ENVIRONMENT}-uptimemonitor"
          
          # Check if service exists
          if ! aws ecs describe-services \
            --cluster $CLUSTER \
            --services $SERVICE \
            --region $AWS_REGION \
            --query 'services[0].status' \
            --output text | grep -q "ACTIVE"; then
            echo "Service not active yet. This might be first deployment."
            echo "Service will use image from task definition on first deployment."
            exit 0
          fi
          
          # Get current task definition
          echo "Fetching current task definition..."
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition $TASK_FAMILY \
            --query 'taskDefinition' \
            --region $AWS_REGION)
          
          # Update all container images (web, celery, beat)
          echo "Updating all container images to: $NEW_IMAGE"
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq --arg IMAGE "$NEW_IMAGE" '
            .containerDefinitions |= map(
              .image = $IMAGE
            ) |
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, 
                .compatibilities, .registeredAt, .registeredBy)
          ')
          
          # Register new task definition revision
          echo "Registering new task definition..."
          NEW_REVISION=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --region $AWS_REGION \
            --query 'taskDefinition.revision' \
            --output text)
          
          echo "New task definition revision: $TASK_FAMILY:$NEW_REVISION"
          
          # Update service with new task definition
          echo "Updating ECS service..."
          aws ecs update-service \
            --cluster $CLUSTER \
            --service $SERVICE \
            --task-definition "$TASK_FAMILY:$NEW_REVISION" \
            --force-new-deployment \
            --region $AWS_REGION \
            --query 'service.taskDefinition' \
            --output text
          
          echo "Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster $CLUSTER \
            --service $SERVICE \
            --region $AWS_REGION
          
          echo "ðŸŽ‰ Infrastructure deployment complete!"
          echo "Note: This deployed the '${ENVIRONMENT}-latest' image tag."
          echo "For specific SHA deployments, use the Application CI/CD workflow."